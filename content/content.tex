\chapter{Introduction}
\label{Introduction}

\section{Purpose}
This document is a specification of the Remote Interoperability Protocol (RIP), which was conceived at UNED for the remote operation of online laboratories (OLs). Instructions on how to correctly implement both a server and a client that talk RIP are also given.

\section{Document Conventions}
For the purpose of this document, we consider that an OL can either be a virtual laboratory (VL) or a remote laboratory (RL).

VLs are simulations and offer experimentation possibilities based on mathematical models.

RLs use lab equipment and perform the experiments in real life, just remotely.

A \textit{simulation model} is understood as software that includes mathematical models that simulates a system for virtual experimentation purposes.

\textit{Control program} is a term used in this document to refer to the software in charge of controlling and monitoring lab equipment.

In this sense, we consider that a VL always has an associated \textit{simulation model} that is hosted and run in some computer, while a RL always has an associated \textit{control program} that is also hosted and run in some computer.

Finally, we define an \textit{experience} as each of the lab activities that can be carried out with an OL implementation, either through a RL or through a VL.

\section{Intended Audience and Reading Suggestions}
Audiences that may be interested in this document are educators, researchers and industry stakeholders that want or need to remotely communicate either with hardware devices or mathematical models from a web application. 

More specifically, this document aims at anyone who is interested in one or more of the following points:

\begin{enumerate}
    \item Implementing a RIP server and/or a RIP client to use RIP as the communication protocol for operating OLs.
    \item Using or modifying an existing RIP server and/or RIP client implementation.
    \item Making modifications on the RIP protocol itself.
\end{enumerate}

In any of the above cases, it is advised to read the present document in order. Before reading this document, it is reccommended to have some notions about TCP \cite{tcp}, HTTP \cite{http}, SSE \cite{sse} and JSON-RPC \cite{jsonrpc}.

\section{Product Scope}
The objective of RIP is to offer a simple, yet powerful, communication solution usable from web clients. As such, RIP only uses pure HTTP standard protocols, supported by all major web browsers.

RIP is designed to communicate web clients with OLs; either VLs or RLs. When used to communicate with a VL, RIP exposes meta-data and input and output methods and variables related to a simulation model that is hosted and runs on a computer (usually, a remote server). When used to communicate with a RL, RIP does the same thing with a \textit{control program} defined in a computer (usually, a remote server) to monitor and manipulate the lab equipment.

Figure \ref{fig:Client-RIP-OL} shows the usage of the RIP protocol implemented in a RIP client and a RIP server to communicate a web client with an OL. The figure represents how an OL can implement either a VL, a RL, or any combination of both, each one defined as an independent \textit{experience}, referenced through a certain \textit{expId} parameter.

\begin{figure}[hb!]
\centering
\includegraphics[width=0.75\textwidth]{images/Client-RIP-OL.pdf}
\caption{RIP protocol is used by a RIP client and a RIP server to communicate both. The RIP server is implemented in an OL and the RIP client is implemented in a web browser application.}
\label{fig:Client-RIP-OL}
\end{figure}


\chapter{Overall Description}
\label{Overall Description}

\section{Protocol Perspective}
The protocol is an open source, under the GNU general Public License. It is a communication protocol to be used in the client-server model, especially designed for OLs in which the client runs within a web browser. RIP provides a simple mechanism for users and client machines/programs to acquire information about the lab \textit{experiences} defined in the server and about each \textit{experience's} inputs and outputs. The protocol also defines methods for reading and writing the values of these inputs and outputs, respectively.

\begin{figure}[b!]
\centering
\includegraphics[width=0.5\textwidth]{images/RIPTechnologies.pdf}
\caption{RIP is based on POST and GET HTTP methods and on the JSON-RPC format.}
\label{fig:RIP_Technologies}
\end{figure}

The main features of RIP are the following:

\begin{enumerate}
    \item Defining \textit{experiences} on the OL.
    \item Obtaining meta-data related to each defined \textit{experience}.
    \item Obtaining a list of readable and writable variables for each \textit{experience}.
    \item Obtaining a list of methods to read and write variables in each \textit{experience}.
    \item Invoking methods to read and write variables in each \textit{experience}.
    \item Defining server events to send data either periodically or based on any other triggering condition defined in an \textit{experience}.
    \item Subscribing a client to any server event declared in an \textit{experience}.
\end{enumerate}

RIP is based on two cornerstones: POST and GET methods for the communications transport and JSON-RPC for formatting messages. POST and GET are HTTP methods, which, in turn, is based on TCP communications. On the other hand, JSON-RPC is based on the JSON format. Figure \ref{fig:RIP_Technologies} represents these ideas.

Communication between two software entities is possible when they talk the same protocol. Therefore, a RIP implementation is needed in both the client and the server.

\subsection{Server Implementation Perspective}
Figure \ref{fig:RIP_Architecture} depicts the architecture of a \emph{RIP Server} that implements the RIP protocol. To sum it up, there are three functional subsystems: the \emph{Web Server}, that handles client connections, user sessions, etc., the \emph{Command Interpreter}, that speaks RIP, and the \emph{Executor}, that controls the execution of the laboratory \textit{control programs} or \textit{simulation models}.

\begin{figure}[b!]
\centering
\includegraphics[width=0.75\textwidth]{images/RIPArchitecture.pdf}
\caption{Architectural view of a RIP Server}
\label{fig:RIP_Architecture}
\end{figure}

The \textit{Web Server} component admits (and handles in different ways) three types of requests: GET (used to retrieve \textit{experiences'} meta-data), SSE (used to get server-to-client data updates) and POST (used to send client-to-server updates or client-to-server requests for data updates). These different methods are each associated with the three basic cases of use, namely:

\begin{itemize}
    \item \emph{Meta-data} - A client, wanting to obtain information about the laboratory, launches an HTTP GET request to the URL associated with the laboratory. The RIP server responds with a JSON-RPC structure that informs the client, depending on the request's parameters, with one of the following:
    
    \begin{enumerate}
        \item General information about the OL: what are the \textit{experiences} defined and how they can be accessed.
        \item Detailed information of a particular \textit{experience} (when the request includes the {experience} id as a parameter).
    \end{enumerate}
    
    \item \emph{Observer} - A client, that desires to receive updates on the state of the plant, subscribes to an SSE event stream associated to the \textit{experience} of interest.
    
    \item \emph{Operator} - A client, wanting to act over the OL or to receive an update on demand, sends a POST request with the command codified as a RIP-JSON-RPC structure.
\end{itemize}

An \textit{experience} represents a lab activity associated with an OL. In the case of RLs, each \textit{experience} is implemented as a \textit{control program}, which in general is responsible of managing the physical connections with the hardware, safe measures, and any other functionality the lab designer has considered appropriate to include. In the case of VLs, each \textit{experience} is implemented as a \textit{simulation model} that represents a real system. The \textit{experience} abstraction is useful for two purposes: 1) to publish information about OLs in a standard and structured way and 2) to allow for hosting and running several different \textit{control programs} or \textit{simulation models} in the same computer.

\subsection{Client Implementation Perspective}
A RIP client must simply implement the required communication protocol methods (that is, POST, GET and SSE) with the appropriate format for reading and writing the messages content (that is, JSON-RPC) and the structure and functions defined by RIP (detailed in later sections).

\section{Protocol Functions (High-Level API)}
The functions defined and used in the protocol are divided in two types: internal and external.

The internal functions are private functions, used internally by RIP server implementations to communicate either with the \textit{simulation model} or the \textit{control program} used in the OL.

The external functions are client-side methods. These functions are used by the RIP clients to both get meta-data about the defined \textit{experiences} and to write and read data to and from the OL.

In this way, RIP servers must implement the internal functions, while RIP clients must implement the external functions (see Figure \ref{fig:Functions_Implementation}). Client-based methods of the external functions in a RIP client communicate with the \textit{Web Server} of a RIP server, get translated by the \textit{Command Interpreter} into a series of one or more internal functions, and are finally executed by the \textit{Executor} component (see Figure \ref{fig:RIP_Architecture}).

\begin{figure}[b!]
\centering
\includegraphics[width=0.75\textwidth]{images/FunctionsImplementation.pdf}
\caption{Internal and external functions implementation in RIP clients and servers}
\label{fig:Functions_Implementation}
\end{figure}

\subsection{Internal Functions}
\label{sec:Internal_Functions}
The list of internal functions a RIP server must implement is:

\begin{enumerate}
    \item \textit{info}  $=$ \textbf{basicInfo}(): Returns the list of \textit{experiences} defined in the OL and meta-data information about the method that can be used to retrieve more information about a particular \textit{experience}.
    \item \textit{info}  $=$ \textbf{experienceInfo}(\textit{expId}): Returns the list of variables defined in the \textit{control program} or \textit{simulation model} associated to the \textit{experience} defined by \textit{expId}, meta-data related to such \textit{experience} and information about the methods that can be used to communicate with the OL.
    \item \textit{readablelist}, \textit{writablelist}  $=$ \textbf{open}(\textit{expId}): Returns the list of readable and writable variables (in two different variables) defined in the \textit{experience} associated to the input \textit{expId} parameter.
    \item \textbf{close}(\textit{expId}): Closes the control program (if it is a RL) or the simulation model (if it is a VL) of the OL \textit{experience} defined by the input \textit{expId} parameter.
    \item \textbf{start}(\textit{expId}): Starts the execution of the \textit{control program} or \textit{simulation model} associated to the OL \textit{experience} defined by the input \textit{expId} parameter by: first, opening it and second, running it.
    \item \textbf{run}(\textit{expId}): Runs the \textit{control program} or \textit{simulation model} associated to the OL \textit{experience} defined by the input \textit{expId} parameter.
    \item \textbf{stop}(\textit{expId}): Stops the execution of the \textit{control program} or \textit{simulation model} associated to the OL \textit{experience} defined by the input \textit{expId} parameter.
    \item \textit{readVariableNames}, \textit{readVariableValues} $=$ \textbf{get}(\textit{expId}, \textit{variableNames}): Retrieves the current values of the variables (\textit{readVariableValues}) specified by the \textit{variableNames} input parameter. For this to happen, these variables must exist in the \textit{control program} or \textit{simulation model} associated to the \textit{experience} defined by the \textit{expId} input parameter. When the \textbf{get()} method is called, \textit{readVariableNames} contains only the names of the variables that were successfully read, not all requested ones in \textit{variableNames}.
    \item \textbf{set}(\textit{expId}, \textit{variableNames}, \textit{variableValues}): Writes the received values (\textit{variableValues}) in the specified variables (\textit{variableNames}) of the appropiate OL \textit{experience}. For this to happen, these variables must exist in the \textit{control program} or \textit{simulation model} associated to the (\textit{expId}) input parameter.
\end{enumerate}

\subsection{External Functions}
\label{sec:External_Functions}
The list of external functions a RIP client must implement is:

\begin{enumerate}
    \item \textit{result} $=$ \textbf{info}(\textit{callback}, \textit{expId} $=$ null): Retrieves the meta-data information about the \textit{experience} defined by the input \textit{expId} parameter. This parameter is optional and if it is not specified, the method then returns meta-data information about all the \textit{experiences} defined.
    \item \textbf{connect}(\textit{expId}, \textit{callback}): Connects to an \textit{experience} defined by the input \textit{expId} parameter and establishes connection to the SSE to start receiving server data updates.
    \item \textbf{set}(\textit{variableNames}, \textit{variableValues}, \textit{callback}, \textit{expId}): Writes the received values (\textit{variableValues}) in the specified variables (\textit{variableNames}) of the appropiate OL \textit{experience}. For this to happen, these variables must exist in the \textit{control program} or \textit{simulation model} associated to the (\textit{expId}) input parameter.
    \item \textit{result} $=$ \textbf{get}(\textit{variableNames}, \textit{callback}, \textit{expId}): Retrieves the current values of the variables (\textit{readVariableValues}) specified by the \textit{variableNames} input parameter. For this to happen, these variables must exist in the \textit{control program} or \textit{simulation model} associated to the \textit{experience} defined by the \textit{expId} input parameter.
\end{enumerate}

Where:

Variables \textit{variableNames} and \textit{variableValues} are arrays of text. For example: \textit{variableNames} $=$ ["x", "y", ...], \textit{variableValues} $=$ ["10", "a", ...].

At the moment, only numbers, text and booleans are supported as valid types for \textit{variableValues} and \textit{readVariableValues} in the \textbf{set}() and \textbf{get}() methods, respectively.

Sections \ref{sec:User_Doc} and \ref{sec:Developer_Doc} give more information about the external and internal functions, respectively.

\section{Protocol Communication Methods (Low-Level API)}
Three HTTP communication methods are available in RIP for communicating the client with the server:

\begin{enumerate}
    \item \textbf{GET} - To obtain OL meta-data. A RIP server must implement a web service endpoint at \url{BaseURL:port/RIP} for attending these requests.
    \item \textbf{POST} - To send client-to-server requests for (i) writing OL variables' values and (ii) reading OL variables' values. A RIP server must implement a web service endpoint at \url{BaseURL:port/RIP/POST} for attending these requests.
    \item \textbf{SSE} - To subscribe the client to data streams so that it receives server-to-client OL variables' values updates. A RIP server must implement a web service endpoint at \url{BaseURL:port/RIP/SSE} for attending these requests.
\end{enumerate}

Table \ref{tab:low-high-levels-correspondence} shows the correspondence between the external protocol functions of the high-level API and the HTTP methods of the low-level API. The right column also indicates the RIP's web server endpoint to which each of the methods and functions communicate with. A representation of these same ideas is shown in Figure \ref{fig:client-server-funtions-correspondence}. While they should, not all internal functions are represented in the Figure; only six out of nine appear in it.

\begin{table}[]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        RIP client function (High-Level API) & \begin{tabular}{@{}c@{}} HTTP Method \\ (Low-Level API) \end{tabular} & Web server endpoint \\
        \hline
        info(callback), info(callback, expId) & GET & /BaseURL:port/RIP \\
        \hline
        \begin{tabular}{@{}c@{}} set(variableNames, variableValues, callback, expId), \\ get(variableNames, expId)\end{tabular} & POST & /BaseURL:port/RIP/POST \\
        \hline
        connect(expId, callback) & SSE & /BaseURL:port/RIP/SSE \\
        \hline
    \end{tabular}
    \caption{Correspondence between RIP external functions, HTTP methods and RIP's web server endpoints}
    \label{tab:low-high-levels-correspondence}
\end{table}

Section \ref{sec:Developer_Doc} gives more information about the use of these HTTP methods in RIP's low-level API.

\section{Operating Environment}
RIP uses only HTTP methods for the communication. Therefore, it works in any major web browser. However, RIP also relies on the use of SSEs, which, up to date, are not supported by Microsoft Internet Explorer nor Microsoft Edge. Nevertheless, there are numerous poly-fill solutions for implementing SSE so that they work on these browsers that do not support them natively.

\section{Design and Implementation Constraints}
RIP is designed to only use pure HTTP methods on purpose, with the aim of guaranteeing its correct functioning from web browsers. Therefore, the only hard implementation constraint is that HTTP is used for implementing RIP communications.

\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth]{images/Correspondence.pdf}
\caption{Illustration of the existing correspondence between RIP functions, HTTP methods and RIP's web server endpoints}
\label{fig:client-server-funtions-correspondence}
\end{figure}

\section{Assumptions and Dependencies}
RIP depends solely on the use of HTTP POST and GET methods and on the JSON format for exchanging data. 
A common and easy way of implementing RIP in web clients is through the use of the EventSource object \cite{sse} (for the SSEs) and the XMLHttpRequest object \cite{xhr} or the Fetch API \cite{fetch} (for the POST messages), which are both supported by all major web browsers. Still, implementations without the use of such APIs are possible, just more laborious. 

RIP server implementations may differ a lot depending on the language used to make the implementation, and so do their possible dependencies.

\section{User Documentation}
\label{sec:User_Doc}
This section provides a deeper insight on the \textbf{external functions of the high-level API} from a final user point of view. This is the only knowledge required by such a user to use a RIP client implementation to communicate with an OL running a RIP server.

A RIP client must implement a class with the methods described in Section \ref{sec:External_Functions}. Next, detailed information of each of them is given. This information includes a description of: 1) the method itself, 2) its input parameters and 3) the result returned by the method. All methods have a \textit{callback} parameter; a function to be called after the method completes its tasks.

\subsection{Method info}
This method has two input parameters: \textit{callback} and  \textit{expId}. It can be called with or without the \textit{expId} parameter.

When called without this parameter, \textbf{info}() returns meta-data with the list of experience identifiers associated to all \textit{experiences} defined in the OL. It also returns more information about the low-level API method call for retrieving meta-data.

When called with the \textit{expId} parameter, \textbf{info}(\textit{expId}) returns meta-data of the referenced \textit{experience}.

The result returned by this method is a string in JSON format containing information about the experience defined in the RIP server with name \textit{expId}. The structure and content of this string depends on whether the method is called with or without the \textit{expId} parameter. In any case, the result is described in detail in section \ref{sec:info}.

The way to call it is:

\textit{result} $=$ \textbf{info}(\textit{callback}, \textit{expId} $=$ null)

\subsection{Method connect}
This method has two input parameters: \textit{expId} and \textit{callback}.

When this method is called, the client connects to an SSE in the RIP server to: 1) control the user session in the server and 2) receive updates of the variables value in the \textit{experience} defined by \textit{expId}.

Although updates on the server's variables values are received upon the connection, this method returns nothing by itself. The way to call it is: 

\textbf{connect}(\textit{expId}, \textit{callback})

\subsection{Method set}
This method has four input parameters: \textit{variableNames} and \textit{variableValues}, \textit{callback} and \textit{expId}, .

When this method is called, the values specified in \textit{variableValues} are assigned to the \textit{control program's} or \textit{simulation model's} variables named as the strings in \textit{variableNames}. The \textit{control program} or \textit{simulation model} is determined with the \textit{expId} parameter. 

This method returns nothing and the way to call it is: \textbf{set}(\textit{variableNames}, \textit{variableValues}, \textit{callback}, \textit{expId})

\subsection{Method get}
This method has three input parameters: \textit{variableNames}, \textit{callback} and \textit{expId}.

When this method is called, the values of the \textit{control program's} or \textit{simulation model's} variables named as the strings in \textit{variableNames} are read and returned. The \textit{control program} or \textit{simulation model} is determined with the \textit{expId} parameter.

The result returned by this method is a mixed array with the current values of the \textit{control program's} or \textit{simulation model's} variables specified in the \textit{variableNames} input parameter.

The way to call it is:

\textit{result} $=$ \textbf{get}(\textit{variableNames}, \textit{callback}, \textit{expId})

\section{Developer Documentation}
\label{sec:Developer_Doc}
This section provides more details on the internal functions of the high-level API and on the low-level API, which represents the knowledge required to either implement a new RIP client or a new RIP server, or to modify existing ones.

\subsection{Internal Functions of the High-Level API}
The High-Level API internal functions are run in the RIP server upon the reception of a GET or POST message, or when an SSE connection is established, mostly. Table \ref{tab:internal-external-correspondence} shows the correspondence between the external function called by the client and the internal function executed at the server.

\begin{table}[b!]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        & \\RIP (client) external function & RIP (server) internal functions \\
        \hline
        & \\info(callback) & basicInfo() \\
        \hline
        & \\info(callback, expId) & experienceInfo() \\
        \hline
        & \\connect(expId, callback) & 1. - start(), 2. - get()_{\CircArrowRight{}} \\
        \hline
        & \\set(variableNames, variableValues, callback, expId) & set() \\
        \hline
        & \\get(variableNames, callback, expId) & get() \\
        \hline
    \end{tabular}
    \caption{Correspondence between RIP external functions and RIP internal functions}
    \label{tab:internal-external-correspondence}
\end{table}

However, the execution of some internal functions are not fired due to the reception of an external function in the RIP server. On the contrary, some internal functions are run when a client disconnection is detected (that's the case of the \textit{stop()} and \textit{close()} methods), or when other internal functions are called (\textit{open()} and \textit{run()} methods). Table summarizes this information.

\begin{table}[b!]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        & \\Trigger condition & Executed RIP (server) internal functions \\
        \hline
        & \\experienceInfo() is run & 1. - [open()], 2. - get(), 3. - [close()] \\
        \hline
        & \\start() is run & 1 . - [open()], 2. - [run()] \\
        \hline
        & \\Client disconnects & 1. - [stop()], 2. - [close()] \\
        \hline
    \end{tabular}
    \caption{Triggering conditions and fired internal methods}
    \label{tab:trigerring-internal-correspondence}
\end{table}

Functions between brackets in Table \ref{tab:trigerring-internal-correspondence} are not necessarily run, and only get executed when needed.

As can be seen in Tables \ref{tab:internal-external-correspondence} and \ref{tab:trigerring-internal-correspondence}, the \textit{get()} internal function can be either run upon a client function reception (\textit{connect(expId)} and \textit{get(expId, variableNames)}) or due to the execution of the \textit{experienceInfo()} internal method. When the client invokes the \textit{connect(expId)} external function, the RIP server runs the \textit{get()} internal function in a loop to get, and then send, constant updates to the client through the established SSE connection.

Each method returns an error indicator when the operation is not completed successfully.

\subsubsection{Method basicInfo}
This method is called only when the RIP server receives an HTTP message from a client with the \textit{info} method and no parameters.

It returns a list of \textit{experiences} defined in the OL and meta-data information about the GET HTTP RIP method described in previous sections to get meta-data.

\subsubsection{Method experienceInfo}
This method is called only when the RIP server receives an HTTP message from a client with the \textit{info} method and the \textit{expId} parameter.

It returns meta-data information about the \textit{experience} and the available HTTP RIP methods described in previous sections to communicate with the OL.

\subsubsection{Method start}
This method is called only when the RIP server receives an HTTP message from a client with the \textit{connect} method and the \textit{expId} parameter.

It runs (when needed) two internal functions in order: first, \textit{open()} and second, \textit{run()}, to open and run the \textit{control program} or \textit{simulation model} associated to the experience, respectively.

\subsubsection{Method open}
This method is run only when either the experienceInfo() or the start() methods are called in the RIP server and there are no other clients using the associated \textit{experience}, which means the corresponding \textit{control program} or \textit{simulation model} is closed.

It opens the \textit{control program} or \textit{simulation model} associated to the experience.

\subsubsection{Method close}
This method is run either when a client disconnection is produced, with the objective of closing the \textit{control program} or \textit{simulations model} that was open to attend the client requests, or when the experienceInfo() method is called and there are no other clients using the associated \textit{experience}.

It closes the \textit{control program} or \textit{simulation model} associated to the experience.

\subsubsection{Method run}
This method is run only when either the start() method is called in the RIP server and there are no other clients using the associated \textit{experience}, which means the corresponding \textit{control program} or \textit{simulation model} is not currently running.

It runs the \textit{control program} or \textit{simulation model} associated to the experience.

\subsubsection{Method stop}
This method is only run when a client disconnection is produced, with the objective of stopping the execution of the \textit{control program}, or \textit{simulations model} that was running to attend the client requests. 

It stops the \textit{control program} or \textit{simulation model} associated to the experience.

\subsubsection{Method get}
This method is called only when the RIP server receives an HTTP message from a client either with the \textit{get} method and the \textit{expId} and \textit{variableNames} parameters or with the \textit{connect} method method and the \textit{expId} parameter. In the first case, this method is called only once. In the second, as an SSE communication is established, the method is called receptively, depending on the events defined in the RIP server.

It returns the list of current values of the variables defined in the \textit{control program} or {simulation model} and the names of the read variables.

\subsubsection{Method set}
This method is called only when the RIP server receives an HTTP message from a client with the \textit{set} method and the \textit{expId}, \textit{variableNames} and \textit{variableValues} parameters.

It writes the values received in the specified variables of the appropriate OL \textit{experience}.

\subsection{Low-Level API}
Each external method from the High-Level API is implemented with an HTTP method that follows the Low-Level API. The nature and structure of the HTTP messages that must be built by each High-Level API method, the RIP server endpoint to which it must connect, and the result returned by the RIP server to each of these messages is detailed in this section.

For the sake of clarity, each method also includes an example. The relevant parameters for this example can be found in Table \ref{tab:low-level-example}.

\begin{table}[]
    \centering
    \begin{tabular}{|c|c|}
        \hline
         & \\Parameter & Value \\
         \hline
         & \\Protocol & http \\
         \hline
         & \\BaseURL & 10.192.38.56 \\
        \hline
        & \\Communication port & 8080 \\
        \hline
         & \\Declared experiences & Test1, Test2 \\
        \hline
         & \\Declared inputs in \textit{control program} & stringin, intin, doublein, booleanin
         \\or \textit{simulation model} for Test1 & \\
        \hline
        & \\Declared outputs in \textit{control program} & stringout, intout, doubleout, booleanout
          \\or \textit{simulation model} for Test1 & \\
        \hline
    \end{tabular}
    \caption{Relevant parameters for the examples.}
    \label{tab:low-level-example}
\end{table}

\subsubsection{Method info - GET}
\label{sec:info}
The \textit{info(callback)} RIP client method sends a GET request to \url{http(s)://BaseURL:port/RIP}, while \textit{info(callback, expIdValue)} does the same with \url{http(s)://BaseURL:port/RIP?expId=expIdValue}.

The result of calling this method without the \textit{expId} input parameter is a JSON object containing one single top-level member:

\begin{myEnumerate}
    \item \textbf{experiences}: A JSON object with the following top-level members:
    \begin{myEnumerate}
        \item \textbf{list}: An array of JSON objects, each of which contains one single top-level member:
        \begin{myEnumerate}
            \item \textbf{id}: A string with the experience identifier (expId) that is unmistakably related to one and only one \textit{experience} defined in the OL.
        \end{myEnumerate}
        \item \textbf{methods}: An array of JSON objects, each of which contains the following top-level members:
        \begin{myEnumerate}
            \item \textbf{url}: A string with the URL to call the method.
            \item \textbf{type}: A string specifying the HTTP method to use.
            \item \textbf{description}: A string describing the method.
            \item \textbf{params}: An array of JSON objects detailing the required and optional parameters for the method:
            \begin{myEnumerate}
                \item \textbf{name}: A string with the name of the parameter
                \item \textbf{required}: A string ("yes" or "no") specifying whether the parameter is required ("yes") or optional ("no").
                \item \textbf{location}: A string referencing the location for the parameter ("query", "header" or "body").
                \item \textbf{value}: [Optional] A string with the required value for the parameter.
                \item \textbf{type}: [Optional] A string detailing the type of the parameter.
                \item \textbf{elements}: [Optional] An array of JSON objects with the following top-level members:
                \begin{myEnumerate}
                    \item \textbf{description}: A string with a description of the parameter element.
                    \item \textbf{type}: A string specifying the type of the parameter element.
                    \item \textbf{subtype}: [Optional] A string detailing the type of the elements inside an array parameter element when they are all of the same type.
                \end{myEnumerate}
                \item \textbf{subtype}: [Optional] A string detailing the type of the elements inside an array parameter when they are all of the same type.
            \end{myEnumerate}
            \item \textbf{returns}: A string with the MIME-type of the method's result.
            \item \textbf{example}: A JSON object with the following top-level members:
            \begin{myEnumerate}
                    \item \textbf{url}: A string with the URL to call the method.
                    \item \textbf{headers}:[Optional] A JSON object with the parameters to be placed on the HTTP request headers with as many top-level members as headers are set:
                    \begin{myEnumerate}
                        \item \textbf{HeaderName}: HeaderValue
                    \end{myEnumerate}
                    \item \textbf{body}: [Optional] A JSON object with the parameters to be placed on the HTTP request body and with the following top-level members:
                    \begin{myEnumerate}
                        \item \textbf{jsonrpc}: "2.0"
                        \item \textbf{method}: A string with the RIP method to invoke ("get", "set" or "connect"). % "start" or "stop").
                        \item \textbf{params}: An array with the following elements:
                        \begin{myEnumerate}
                            \item \textbf{expId}: A string with the \textit{eperience} identifier.
                            \item \textbf{variableNames}: An array of strings in which each element has the name of a variable in the \textit{control program} or in the \textit{simulation model}.
                            \item \textbf{variableValues}: [Optional] An array of strings with the values to be written in the variables specified in the \textit{variableNames} member, following the same order.
                        \end{myEnumerate}
                        \item \textbf{id}: A string with a number that indicates how many request have been sent till now, including this one.
                    \end{myEnumerate}
            \end{myEnumerate}
        \end{myEnumerate}
    \end{myEnumerate}
\end{myEnumerate}

\textbf{\underline{Example:}}

\textit{Request:}

The \textit{info(callback)} RIP client method sends a GET request to: \url{http://10.192.38.56:8080/RIP}

\textit{Response:}

The RIP server responds to the GET message with the following body:

\begin{lstlisting}
{
  "experiences": {
    "list": [
              {
              "id": "Test1"
              },
              {
              "id": "Test2"
              }
            ],
    "methods": [
                  {
                  "url": "10.192.38.56:8080/RIP",
                  "type": "GET",
                  "description": "Retrieves information (variables and methods) of the experiences in the server",
                  "params": [
                               {
                               "name": "Accept",
                               "required": "no",
                               "location": "header",
                               "value": "application/json"
                               },
                               {
                               "name": "expId",
                               "required": "no",
                               "location": "query",
                               "type": "string" 
                               }
                            ],
                  "returns": "application/json",
                  "example": {
                             "url": "10.192.38.56:8080/RIP?expId=Test1"
                             }
                  }
               ]
    }
}
\end{lstlisting}

The result of calling this method with the \textit{expId} input parameter is a JSON object containing three top-level members:

\begin{myEnumerate}
    \item \textbf{info}: A JSON object with the following top-level members:
    \begin{myEnumerate}
        \item \textbf{name}: A string with the name given to the experience.
        \item \textbf{description}: A string with a description of the experience.
        \item \textbf{authors}: A string with the name of the authors of the experience, separated by commas.
        \item \textbf{keywords}: An array of strings, each with a keyword related to the experience.
    \end{myEnumerate}
    \item \textbf{readables}: A JSON object with the following top-level members:
    \begin{myEnumerate}
        \item \textbf{list}: An array of JSON objects with the following top-level members:
        \begin{myEnumerate}
            \item \textbf{name}: A string with the name of the variable.
            \item \textbf{description}: A string with a description of the variable.
            \item \textbf{type}: A string with the type of the variable: \textit{"string"}, \textit{"int"}, \textit{"float"} or \textit{"boolean"}.
            \item \textbf{min}: A string with the minimum value the variable can have. In case of boolean variables, \textit{"false"}; in case of string variables, \textit{""}; in any other case, any number in string format.
            \item \textbf{max}: A string with the minimum value the variable can have. In case of boolean variables, \textit{"true"}; in case of string variables, \textit{""}; in any other case, any number in string format.
            \item \textbf{precision}: A string with the minimum value the variable can have. In case of boolean or string variables, \textit{""}; in any other case, any number in string format.
        \end{myEnumerate}
        \item \textbf{methods}: EXACTLY AS the \textit{methods} top-level member from the \textit{experiences} JSON object returned by the \textit{info(callback)} method when called without the \textit{expId} parameter: an array of JSON objects, each of which contains the following top-level members:
        \begin{myEnumerate}
            \item \textbf{url}: A string with the URL to call the method.
            \item \textbf{type}: A string specifying the HTTP method to use.
            \item \textbf{description}: A string describing the method.
           \item \textbf{params}: An array of JSON objects detailing the required and optional parameters for the method:
            \begin{myEnumerate}
                \item \textbf{name}: A string with the name of the parameter
                \item \textbf{required}: A string ("yes" or "no") specifying whether the parameter is required ("yes") or optional ("no").
                \item \textbf{location}: A string referencing the location for the parameter ("header", "query" or "body").
                \item \textbf{value}: [Optional] A string with the required value for the parameter.
                \item \textbf{type}: [Optional] A string detailing the type of the parameter.
                \item \textbf{elements}: [Optional] An array of JSON objects with the following top-level members:
                \begin{myEnumerate}
                    \item \textbf{description}: A string with a description of the parameter element.
                    \item \textbf{type}: A string specifying the type of the parameter element.
                    \item \textbf{subtype}: [Optional] A string detailing the type of the elements inside an array parameter element when they are all of the same type.
                \end{myEnumerate}
                \item \textbf{subtype}: [Optional] A string detailing the type of the elements inside an array parameter when they are all of the same type.
            \end{myEnumerate}
            \item \textbf{returns}: A string with the MIME-type of the method's result.
            \item \textbf{example}: A JSON object with the following top-level members:
            \begin{myEnumerate}
                    \item \textbf{url}: A string with the URL to call the method.
                    \item \textbf{headers}:[Optional] A JSON object with the parameters to be placed on the HTTP request headers with as many top-level members as headers are set:
                    \begin{myEnumerate}
                        \item \textbf{HeaderName}: HeaderValue
                    \end{myEnumerate}
                    \item \textbf{body}: [Optional] A JSON object with the parameters to be placed on the HTTP request body and with the following top-level members:
                    \begin{myEnumerate}
                        \item \textbf{jsonrpc}: "2.0"
                        \item \textbf{method}: A string with the RIP method to invoke ("get", "set" or "connect"). %, "start" or "stop").
                        \item \textbf{params}: An array with the following elements:
                        \begin{myEnumerate}
                            \item \textbf{expId}: A string with the \textit{eperience} identifier.
                            \item \textbf{variableNames}: An array of strings in which each element has the name of a variable in the \textit{control program} or in the \textit{simulation model}.
                            \item \textbf{variableValues}: [Optional] An array of strings with the values to be written in the variables specified in the \textit{variableNames} member, following the same order.
                        \end{myEnumerate}
                        \item \textbf{id}: A string with a number that indicates how many request have been sent till now, including this one.
                    \end{myEnumerate}
            \end{myEnumerate}
        \end{myEnumerate}
    \end{myEnumerate}
    \item \textbf{writables}: A JSON object with the following top-level members:
    \begin{myEnumerate}
        \item \textbf{list}: EXACTLY AS the \textit{list} top-level member from \textit{readables}: an array of JSON objects with the following top-level members:
        \begin{myEnumerate}
            \item \textbf{name}: A string with the name of the variable.
            \item \textbf{description}: A string with a description of the variable.
            \item \textbf{type}: A string with the type of the variable: \textit{"string"}, \textit{"int"}, \textit{"float"} or \textit{"boolean"}.
            \item \textbf{min}: A string with the minimum value the variable can have. In case of boolean variables, \textit{"false"}; in case of string variables, \textit{""}; in any other case, any number in string format.
            \item \textbf{max}: A string with the minimum value the variable can have. In case of boolean variables, \textit{"true"}; in case of string variables, \textit{""}; in any other case, any number in string format.
            \item \textbf{precision}: A string with the minimum value the variable can have. In case of boolean or string variables, \textit{""}; in any other case, any number in string format.
        \end{myEnumerate}
        \item \textbf{methods}: EXACTLY AS the \textit{methods} top-level member from the \textit{experiences} JSON object returned by the \textit{info(callback)} method when called without the \textit{expId} parameter: an array of JSON objects, each of which contains the following top-level members:
        \begin{myEnumerate}
            \item \textbf{url}: A string with the URL to call the method.
            \item \textbf{type}: A string specifying the HTTP method to use.
            \item \textbf{description}: A string describing the method.
            \item \textbf{params}: An array of JSON objects detailing the required and optional parameters for the method:
            \begin{myEnumerate}
                \item \textbf{name}: A string with the name of the parameter
                \item \textbf{required}: A string ("yes" or "no") specifying whether the parameter is required ("yes") or optional ("no").
                \item \textbf{location}: A string referencing the location for the parameter ("header", "query" or "body").
                \item \textbf{value}: [Optional] A string with the required value for the parameter.
                \item \textbf{type}: [Optional] A string detailing the type of the parameter.
                \item \textbf{elements}: [Optional] An array of JSON objects with the following top-level members:
                \begin{myEnumerate}
                    \item \textbf{description}: A string with a description of the parameter element.
                    \item \textbf{type}: A string specifying the type of the parameter element.
                    \item \textbf{subtype}: [Optional] A string detailing the type of the elements inside an array parameter element when they are all of the same type.
                \end{myEnumerate}
                \item \textbf{subtype}: [Optional] A string detailing the type of the elements inside an array parameter when they are all of the same type.
            \end{myEnumerate}
            \item \textbf{returns}: A string with the MIME-type of the method's result.
            \item \textbf{example}: A JSON object with the following top-level members:
            \begin{myEnumerate}
                    \item \textbf{url}: A string with the URL to call the method.
                    \item \textbf{headers}:[Optional] A JSON object with the parameters to be placed on the HTTP request headers with as many top-level members as headers are set:
                    \begin{myEnumerate}
                        \item \textbf{HeaderName}: HeaderValue
                    \end{myEnumerate}
                    \item \textbf{body}: [Optional] A JSON object with the parameters to be placed on the HTTP request body and with the following top-level members:
                    \begin{myEnumerate}
                        \item \textbf{jsonrpc}: "2.0"
                        \item \textbf{method}: A string with the RIP method to invoke ("get", "set" or "connect"). %, "start" or "stop").
                        \item \textbf{params}: An array with the following elements:
                        \begin{myEnumerate}
                            \item \textbf{expId}: A string with the \textit{eperience} identifier.
                            \item \textbf{variableNames}: An array of strings in which each element has the name of a variable in the \textit{control program} or in the \textit{simulation model}.
                            \item \textbf{variableValues}: [Optional] An array of strings with the values to be written in the variables specified in the \textit{variableNames} member, following the same order.
                        \end{myEnumerate}
                        \item \textbf{id}: A string with a number that indicates how many request have been sent till now, including this one.
                    \end{myEnumerate}
            \end{myEnumerate}
        \end{myEnumerate}
    \end{myEnumerate}
\end{myEnumerate}

\textbf{\underline{Example:}}

\textit{Request:}

The \textit{info(callback, expId)} RIP client method sends a GET request to: \url{http://10.192.38.56:8080/RIP?expId=Test1}

\textit{Response:}

The RIP server responds to the GET message with the following body:

\begin{lstlisting}
{
"info": {
        "name": "Test1",
        "description": "Test1",
        "authors": "L. de la Torre",
        "keywords": ["Test", "Example"]
        },
"readables": {
    "list": [
               {
               "name": "intout",
               "description": "Integer output",
               "type": "int",
               "min": "-20",
               "max": "10",
               "precision":"1"
               },
               {
               "name": "stringout",
               "description": "String output",
               "type": "string",
               "min": "",
               "max": "",
               "precision": ""
               },
               {
               "name": "booleanout",
               "description": "Boolean output",
               "type": "boolean",
               "min": "false",
               "max": "true",
               "precision":""
               },
               {
               "name": "doubleout",
               "description": "Double output",
               "type": "float",
               "min": "-Inf",
               "max": "Inf",
               "precision": "0"
               }
            ],
    "methods": [  
                  {
                  "url": "10.192.38.56:8080/RIP/SSE",
                  "type": "GET",
                  "description": "Subscribes to an SSE to get regular updates on the servers' variables",
                  "params": [
                               {
                               "name": "Accept",
                               "required": "no",
                               "location": "header",
                               "value": "application/json"
                               },
                               {
                               "name": "expId",
                               "required": "yes",
                               "location": "query",
                               "type": "string"
                               },
                               {
                               "name": "variables",
                               "required": "no",
                               "location": "query",
                               "type": "array",
                               "subtype": "string"
                               }
                            ],
                  "returns": "text/event-stream",
                  "example": "10.192.38.56:8080/RIP/SSE?expId=TestOK"
                  },
                  {
                  "url": "10.192.38.56:8080/RIP/POST",
                  "type": "POST",
                  "description": "Sends a request to retrieve the value of one or more servers' variables on demand",
                  "params": [
                               {
                               "name": "Accept",
                               "required": "no",
                               "location": "header",
                               "value": "application/json"
                               },
                               {
                               "name": "Content-Type",
                               "required": "yes",
                               "location": "header",
                               "value": "application/json"
                               },
                               {
                               "name": "jsonrpc",
                               "required": "yes",
                               "type": "string",
                               "location": "body",
                               "value": "2.0"
                               },
                               {
                               "name": "method",
                               "required": "yes",
                               "type": "string",
                               "location": "body",
                               "value": "get"
                               },
                               {
                               "name": "params",
                               "required": "yes",
                               "type": "array",
                               "elements": [
                                   {
                                   "description": "Experience id",
                                   "type":"string"
                                   },
                                   {
                                   "description":"Name of variables to be retrieved",
                                   "type": "array",
                                   "subtype": "string"
                                   }
                                ],
                              "location": "body"
                              },
                              {
                              "name": "id",
                              "required": "yes",
                              "type": "int",
                              "location":"body"
                              }
                            ],
                  "returns": "application/json",
                  "example": {
                             "url": "10.192.38.56:8080/RIP/POST",
                             "headers": {
                                        "Accept": "application/json",
                                        "Content-Type": "application/json"
                                        },
                             "body": {
                                     "jsonrpc": "2.0",
                                     "method": "get",
                                     "params": [
                                                  "Test1",
                                                  ["intout","booleanout"]
                                               ],
                                     "id":"1"
                                     }
                             }
                  },
                  {
                  "url": "http://camera1_ip/axis-cgi/mjpg/video.cgi",
                  "type": "GET",
                  "description": "Retrieve an image of the lab captured from the camera: 'Camera 1'",
                  "params": [
                               {
                               "name": "resolution",
                               "required": "no",
                               "location": "query",
                               "type": "string"
                               },
                               {
                               "name": "user",
                               "required": "no",
                               "location": "query",
                               "type": "string"
                               },
                               {
                               "name": "password",
                               "required": "no",
                               "location": "query",
                               "type": "string"
                               }
                            ],
                  "returns": "video/x-motion-jpeg",
                  "example": {
                             "url": "http://camera1_ip/axis-cgi/mjpg/video.cgi"
                             }
               ]
             },
"writables": {
    "list": [
               {
               "name": "intin",
               "description": "Integer input",
               "type": "int",
               "min": "-20",
               "max": "10",
               "precision":"1"
               },
               {
               "name": "booleanin",
               "description": "Boolean input",
               "type": "boolean",
               "min": "false",
               "max": "true",
               "precision": ""
               },
               {"name": "stringin",
               "description": "String input",
               "type": "string",
               "min": "",
               "max": "",
               "precision":""
               },
               {
               "name": "doublein",
               "description": "Double input",
               "type": "float",
               "min": "-Inf",
               "max": "Inf",
               "precision": "0"
               }
            ],
    "methods": [
                  {
                  "url": "10.192.38.56:8080/RIP/POST",
                  "type": "POST",
                  "description": "Sends a request to write the value of one or more servers' variables on demand",
                  "params": [
                               {
                               "name": "Accept",
                               "required": "no",
                               "location": "header",
                               "value": "application/json"
                               },
                               {
                               "name": "Content-Type",
                               "required": "yes",
                               "location": "header",
                               "value": "application/json"
                               },
                               {
                               "name": "jsonrpc",
                               "required": "yes",
                               "type": "string",
                               "location": "body",
                               "value": "2.0"
                               },
                               {
                               "name": "method",
                               "required": "yes",
                               "type": "string",
                               "location": "body",
                               "value": "set"
                               },
                               {
                               "name": "params",
                               "required": "yes",
                               "type": "array",
                               "elements": [
                                              {
                                              "description": "Experience id",
                                              "type": "string"
                                              },
                                              {
                                              "description": "Name of variables to write",
                                              "type": "array",
                                              "subtype":"string"
                                              },
                                              {
                                              "description": "Value for variables",
                                              "type": "array",
                                              "subtype":"mixed"
                                              }
                                           ],
                               "location": "body"
                               },
                               {
                               "name": "id",
                               "required": "yes",
                               "type": "int",
                               "location": "body"
                               }
                            ],
                  "returns": "application/json",
                  "example": {
                             "url: "10.192.38.56:8080/RIP/POST",
                             "headers": {
                                        "Accept": "application/json",
                                        "Content-Type": "application/json"
                                        },
                             "body": {
                                     "jsonrpc": "2.0",
                                     "method": "set",
                                     "params": [
                                                 "Test1",
                                                 ["intin","stringin"],
                                                 ["2","hello"]
                                               ],
                                     "id": "1"
                                     }
                             }
                  }
               ]
             }
}
\end{lstlisting}

\subsubsection{Method connect - SSE}
\label{sec:connect}
The \textit{connect(expIdValue, callback)} RIP client method establishes an SSE connection with: \url{http(s)://BaseURL:port/RIP/SSE?expId=expIdValue}.

When this method is called, an SSE communication is established with the RIP server. The result is a stream of data (which periodicity or aperiodicity is defined in the server) that can be captured by the onmessage() and the addEventListener() methods of the EventSource object, for example \cite{sse}. The structure of the data obtained through the established SSE follows the SSE standard:

\begin{myEnumerate}
    \item \textbf{retry}: A number specifying the time (in miliseconds) to wait before the client tries to automatically reconnect to the SSE. This field appear only once per connection.
    \item \textbf{event}: The name of the event that follows
    \item \textbf{id}: A unique number that identifies the event.
    \item \textbf{data}: A JSON object with just one top-level members:
    \begin{myEnumerate}
        \item \textbf{result}: An array with the following elements:
        \begin{myEnumerate}
            \item \textbf{variableNames}: An array of strings with the names of the retrieved variables.
            \item \textbf{variableValues}: A mixed array with the values of the retrieved variables.
        \end{myEnumerate}
    \end{myEnumerate}
\end{myEnumerate}

\textbf{\underline{Example:}}

\textit{Request:}

The \textit{connect("Test1")} RIP client method establishes an SSE connection with: \url{http://10.192.38.56:8080/RIP/SSE?expId=Test1}.

\textit{Response:}

The RIP server responds with a stream of data that follows this format:

\begin{lstlisting}
retry: 2000

event: periodiclabdata
id: 1
data: 
{
"result": [
             [
               "intout",
               "doubleout",
               "stringout",
               "booleanout"
             ],
             [
               -2,
               3.5,
               "testing",
               true
             ]
          ]
}
\end{lstlisting}

A RIP client implementation must automatically capture these events and assign the received values to their corresponding variables in the client side.

\subsubsection{Method set - POST}
\label{sec:set}
The \textit{set(variableNames, variableValues, callback, expIdValue)} RIP client method sends a POST request to: \url{http(s)://BaseURL:port/RIP/POST?expId=expIdValue} with a JSON body with the following top-level members:

\begin{myEnumerate}
    \item \textbf{jsonrpc}: "2.0"
    \item \textbf{method}: "set".
    \item \textbf{params}: An array with the following elements:
    \begin{myEnumerate}
        \item \textbf{expId}: A string with the \textit{experience} identifier.
        \item \textbf{variableNames}: An array of strings with the name of the variables in the \textit{control program} or \textit{simulation model} whose values are going to be overwritten.
        \item \textbf{variableValues}: A mixed array with the values to write in the \textit{control program's} or \textit{simulation model's} variables.
    \end{myEnumerate}
    \item \textbf{id}: A string with a number that indicates how many request have been sent till now, including this one.
\end{myEnumerate}

This method returns a JSON object with information about the result of the operation. The resulting JSON object contains the following top-level members:

\begin{myEnumerate}
    \item \textbf{jsonrpc}: "2.0"
    \item \textbf{result}: Either \textit{true}, if the operation was completed succesfully by the RIP server, or \textit{false}, if it was not.
    \item \textbf{id}: A string with a number that indicates how many request have been sent till now, including this one.
\end{myEnumerate}

\textbf{\underline{Example:}}

\textit{Request:}

The \textit{set("Test1", ["doublein", "intin"], [0.5, -1])} RIP client method sends a POST request to: \url{http(s)://BaseURL:port/RIP/POST?expId=Test1} with body:

\begin{lstlisting}
{
"jsonrpc": "2.0",
"method": "set",
"params": [
	         "Test1",
	         ["doublein", "intin"],
	         [0.5, -1]
          ],
"id": "2"
}
\end{lstlisting}

\textit{Response:}

The RIP server responds to the POST message with the following body:

\begin{lstlisting}
{
"jsonrpc": "2.0",
"result": true,
"id": "2"
}
\end{lstlisting}

\subsubsection{Method get - POST}
The \textit{set(variableNames, callback, expIdValue)} RIP client method sends a POST request to: \url{http(s)://BaseURL:port/RIP/POST?expId=expIdValue} with a JSON body with the following top-level members:

\begin{myEnumerate}
    \item \textbf{jsonrpc}: "2.0"
    \item \textbf{method}: "get".
    \item \textbf{params}: An array with the following elements:
    \begin{myEnumerate}
        \item \textbf{expId}: A string with the \textit{experience} identifier.
        \item \textbf{variableNames}: An array of strings with the name of the variables in the \textit{control program} or \textit{simulation model} whose values are going to be retrieved.
    \end{myEnumerate}
    \item \textbf{id}: A string with a number that indicates how many request have been sent till now, including this one.
\end{myEnumerate}

This method returns a JSON object that contains the following top-level members:

\begin{myEnumerate}
    \item \textbf{jsonrpc}: "2.0"
    \item \textbf{result}: An array with the following elements:
    \begin{myEnumerate}
        \item \textbf{variableNames}: An array of strings with the names of the retrieved variables.
        \item \textbf{variableValues}: A mixed array with the values of the retrieved variables.
    \end{myEnumerate}
    \item \textbf{id}: A string with a number that indicates how many request have been sent till now, including this one.
\end{myEnumerate}

\textbf{\underline{Example:}}

\textit{Request:}

The \textit{get("Test1", ["doubleout", "intout"])} RIP client method sends a POST request to: \url{http(s)://BaseURL:port/RIP/POST?expId=Test1} with body:

\begin{lstlisting}
{
"jsonrpc": "2.0",
"method": "get",
"params": [
  	         "Test1",
  	         ["doubleout", "intout"]
          ],
"id": "3"
}
\end{lstlisting}

\textit{Response:}

The RIP server responds to the POST message with the following body:

\begin{lstlisting}
{
"jsonrpc": "2.0",
"result": [
            [
              "doubleout",
              "intout"
            ],
            [
              0.5,
              -1
            ]
          ],
"id": "3"
}
\end{lstlisting}


\chapter{Protocol Features}
\label{System Features}

This chapter describes the main features of RIP. Some features are client-based while others are server-based. This is specified every time a new features is presented.

\section{Defining Experiences and Meta-data}
This is a server-based feature. RIP supports the definition of different experiences within a server. Experiences can be all associated to just one OL or to different ones. An experience gets defined by the next required data:

\begin{itemize}
    \item \textbf{Control program or simulation model}: Each OL experience requires the \textit{control program} or \textit{simulation model} that handles the connection to the hardware, in case of a RL, or that computes the mathematical model of the system, in case of a VL.
    \item \textbf{Path to control program or simulation model}: All experiences must define the path to the \textit{control program} or \textit{simulation model} within the machine that hosts the RIP server.
    \item \textbf{Experience identifier (expId)}: The experience id, or \textit{expId}, unequivocally identifies a particular experience defined in the RIP server.
\end{itemize}

Additionally, the next optional meta-data can also be provided for each experience:

\begin{itemize}
    \item \textbf{Authors}: Experiences may include a list of authors. When not specified, this information is sent as an empty string.
    \item \textbf{Keywords}: Experiences may include a list of related terms or keywords. When not specified, this information is sent as an empty string.
    \item \textbf{Description}: Experiences may include a description that gives more information about the experience objectives, possible experimental tasks and so on. When not specified, this information is sent as an empty string.
    \item \textbf{Cameras}: Experiences may include a list of accessible URLs that stream the video grabbed by the associated cameras.
\end{itemize}

\section{Defining Readable and Writable Variables}
This is a server-based feature. The RIP server implementation has a list of fully defined readable and writable variables from the control program or simulation model associated to each defined experience. In this context, we understand a variable is fully defined when it provides the following information:

\begin{itemize}
    \item \textbf{Name}: The name of the variable.
    \item \textbf{Nature}: Whether it is a readable or a writable variable or both.
    \item \textbf{Description}: A brief description about the variable purpose/meaning.
    \item \textbf{Type}: Whether the variable is a boolean, a number, a string or an array.
    \item \textbf{Min value}: The minimum value the variable can take. In case of boolean variables, \textit{"false"}; in case of string variables, \textit{""}; in any other case, any number in string format.
    \item \textbf{Max value}: The maximum value the variable can take. In case of boolean variables, \textit{"true"}; in case of string variables, \textit{""}; in any other case, any number in string format.
    \item \textbf{Precision}: The minimum increase/decrease in which the values of the variable can be modified. In case of boolean or string variables, \textit{""}; in any other case, any number in string format.
\end{itemize}

Ideally, and if the control programs/simulation models allow it, the RIP server implementation will build the list of fully defined variables automatically. This may depend on the the features offered by the control programs and simulation models. If this list cannot be built automatically by the RIP server, then it must provide a way to allow a human user to create such list for each control program or simulation model that requires it.

\section{Obtaining Meta-data}
This is a client-based feature. There are two levels of meta-data a client can obtain from a RIP server:

\begin{itemize}
    \item \textbf{General}: The client retrieves information about the experiences defined in the RIP server and the available method to get more information about them. This was presented in Section \ref{sec:info}, when the GET method is called without parameters.
    \item \textbf{Related to an experience}: The client retrieves information about the input and output variables (defined in the "Defining Readable and Writable Variables" server-based feature). It also gets the meta-data associated to that experience (defined in the "Defining Experiences and Meta-data" server-based feature). Finally the client also obtains information about the built-in interface methods, provided by RIP, it can call to communicate with the OL. This was presented in Section \ref{sec:info}, when the GET method is called with the \textit{expId} parameter.
\end{itemize}

\section{Reading Readable Variables and Writing Writable Variables}
This is a client-based feature. It allows a client to use RIP's built-in interface methods to read and write variables from/to the control programs and simulation models. It was presented in Sections \ref{sec:set} (for writable variables) and \ref{sec:connect} (for readable ones).

\section{Concurrent Multi-user Connection}
This is a client-based feature. RIP communication methods (POST and SSE) allow multiple clients to send and receive data from the OLs at the same time. The server does not store any state about the client session on the server side that could prevent on a new user to send and/or receive data.

In particular, any number of clients can connect to the SSE to receive updates on an OL's variables simultaneously. POST messages received from clients wanting to write a value in a variable are processed in a first-in, first-out basis.

Any session control, aside from detecting client connections and disconnections to and from the SSE, must be done outside RIP.

\section{Defining and Subscribing to Server Events}
The communication protocol needs to consider two equally important aspects: the definition of the triggering conditions that fire an event in the server and the subscription to the produced event streams. Indeed, a certain client user may be interested in subscribing only to a subset of the event streams produced by one or more already defined event triggers, a second client user could need to subscribe to a different subset to carry out its operations, and a third client user may need to define new event triggers to properly work.

\begin{figure}[b!]
\begin{center}
\centering
\includegraphics[width=0.8\columnwidth]{images/workflow_global.pdf}
\caption{Global communication workflow in RIP for event subscription and definition. [POST-r] means a new POST request is issued from the client to the server and [POST-a] indicates that the server answers to the last received POST request.}
\label{fig:global_workflow}
\end{center}
\end{figure}

The global communication workflow (see Figure \ref{fig:global_workflow}) is as follows:

\begin{enumerate}
	\item The client application sends a POST request to ask the server about the already defined event triggers (which can may have been defined either by the communication protocol implementation or by the plant owner/expert, as it is described in the next subsection). 
	\item The server answers with the information, containing all relevant data associated to each defined rule: name, author, description and a list of the parameters that need to be set. 
	\item The client user decides whether to define a new event trigger or not.
	\item The client user decides which event streams to subscribe to, including those produced by event triggers defined by the RIP communication protocol implementation, the plant owner/expert and those defined by himself. If some parameters need to be configured with values (for instance, $\delta$, in the send-on-delta strategy example presented in the next subsection), the client sets them in this step.
\end{enumerate}

\subsection{Defining Server Events}
The RIP specification considers three actors who can define server events: 1) the OL owner/provider, 2) the RIP specification itself and 3) the OL user. For the first two actors, this is a server-based feature. For the last one, this feature requires implementation in both the server and the client. Figure \ref{fig:actors} provides more details.

\begin{figure}[b!]
\begin{center}
\centering
\includegraphics[width=\columnwidth]{images/actors.pdf}
\caption{Actors that can play a role in defining event triggers: the plant owner/expert (who usually does the deployment of the system on the Internet), the client user (who uses the client application to control the plant) and the RIP communication protocol (CP) implementation itself, formed by both the RIP client implementation (CI) and the RIP server implementation (SI). Rules that define the event triggers are written in the \textit{triggers configuration file}, which can be edited by any of the three actors.}
\label{fig:actors}
\end{center}
\end{figure}

While supporting three different actors to define event triggers may look redundant, each case presents its own advantages and disadvantages. This document will use the send-on-delta strategy as an event triggering condition example to illustrate the way each of the actors could define and implement it. While a detailed description of this technique can be found in the literature, for the purpose of this document it is enough to say that it relies on sending data every time the error of a controlled variable is bigger than a certain $\delta$ value. In mathematical form, and following the notation in Figure \ref{fig:actors}, data is sent to the client when:

\begin{equation}
e(t) = |y_{ref}(t) - y(t)| > \delta
\label{eq:send-on-delta}
\end{equation}

\begin{enumerate}
	\item \textit{Event triggers included by the RIP SSE-based communication protocol implementation.} Any implementation of the proposed communication protocol must: 1) send the client signals to the plant and 2) send the output of the plant to the client. This information can be used by the RIP communication protocol implementation to check and determine if certain conditions are met to decide whether to send data (trigger the event) to the client or not. These built-in event triggers would only include parameterizable basic types of well-known event triggering conditions that require little insight of the process itself. The main advantage of letting RIP to include the definition of some general events is that neither the plant expert nor the user need to do it, saving time and work in many applications. Instead, only the parameters that affect the event trigger must be set, either by the plant expert or by the client user. This is the way any of these two actors provide its knowledge to the process control. In the example of the send-on-delta strategy, the logic to send data when Equation \ref{eq:send-on-delta} is satisfied, would already be written in the RIP communication protocol implementation, ready to be used by any plant and client without any extra work rather than setting the value of $\delta$ in the triggers configuration file.
	\item \textit{Event triggers defined by the plant expert.} The RIP communication protocol implementation may not include an event trigger strategy that suits the needs of an specific OL, plant or process. In this case, the expert/owner of such system can easily define its own rules so that the communication protocol understands them and use them for triggering the events that send the data to the client. The main advantage of this approach is that it provides the communication protocol with a great flexibility to support very specific and specialized event triggering conditions, allowing the expert/owner of the system to define the strategy that works best with the plant. The disadvantage is that it requires more work than just tuning the parameters of built-in event triggers. In the example of the send-on-delta strategy, the system expert/owner would need to write Equation \ref{eq:send-on-delta} in the triggers configuration file, as well as set the value for the $\delta$ parameter.
	\item \textit{Event triggers defined by the client user.} It is easy to imagine scenarios in which it is interesting to allow a client user to define her own event triggering conditions. The first one is in the context of educational OLs where part of the learning practice is to make the student decide and implement the event trigger strategy. A second one is when neither the communication protocol implementation nor the plant owner/expert provide any event trigger on their own. The greatest advantage of this option is that any user can define its own event triggering rules, whether the communication protocol implementation or the plant expert/owner have include any or not. This allows the greatest flexibility but the cost is that it requires more knowledge from the client. In the example of the send-on-delta strategy, and end user would write Equation \ref{eq:send-on-delta} in the web application and RIP would send it to the server where this rule would be written into the triggers configuration file.
\end{enumerate}

Writing the event triggering conditions in the triggers configuration file can be done in two different ways, depending on the actor. When the plant owner/expert is defining her own rules or just setting the value of built-in triggers' parameters, the best option is that the RIP server implementation provides an editor interface to read and write the file. For supporting client users to define these rules or set the parameters of existing ones, RIP provides this feature as a web service. This is described in the next subsection.

\begin{figure}[b!]
\begin{center}
\centering
\includegraphics[width=0.4\columnwidth]{images/workflow_define.pdf}
\caption{Communication workflow for a client that defines a new event trigger. [POST-r] means a new POST request is issued from the client to the server and [POST-a] indicates that the server answers to the last received POST request.}
\label{fig:define_workflow}
\end{center}
\end{figure}

The communication workflow for a client user to define event triggers is as follows (see Figure \ref{fig:define_workflow}):

\begin{enumerate}
	\item The client user indicates in the client application that a new event trigger is being defined. 
	\item Through the communication protocol, the client application fires a POST request to the server.
	\item The server answers with the name of the programming language in which the event triggering condition must be written.
	\item The client user writes the triggering rule, including its possible parameters.
	\item The client application, through the communication protocol, sends a new POST request to the server with this information.
	\item The server writes the rule in the triggers configuration file.
	\item The server responds to the client to let it know that it can start the parameterization and subscription request.
\end{enumerate}

\subsection{Subscribing to Server Events}
This is a client-based feature. 

\begin{figure}[b!]
\begin{center}
\centering
\includegraphics[width=0.4\columnwidth]{images/workflow_subscribe.pdf}
\caption{Communication workflow for a client that sets the parameters of an event trigger and subscribes to its event stream. [POST-r] means a new POST request is issued from the client to the server and [POST-a] indicates that the server answers to the last received POST request.}
\label{fig:subscribe_workflow}
\end{center}
\end{figure}

The communication workflow for a client user to subscribe to a certain subset of event streams and set values for the required parameters is as follows (see Figure \ref{fig:subscribe_workflow}):

\begin{enumerate}
	\item The client user selects which events is going to subscribe to and writes the values for the associated parameters. 
	\item The client application, through the communication protocol, fires a POST request to the server with the list of selected event streams and the values of the parameters.
	\item The server answers to let know the client application that everything is settled and that the control of the process can start.
\end{enumerate}

After the process is finished, the communication protocol implementation configures the SSE so that only the subscribed events, triggered by the selected triggering conditions, are received by the client. For simplicity, this work has considered that all even streams would contain the same information; for example, the output of the plant and its state. However, the proposed communication protocol can be easily extended to allow the three actors to also define the information each event stream could contain. For example, an event stream created by a certain event trigger, \textit{A}, may send to the client only the output of the plant, while the event stream produced by a different event trigger, \textit{B}, may send the whole state of the plant.


\begin{appendices}

\chapter{Glossary}
\textbf{Control program -} A software program which purpose is to control and monitor the hardware equipment used to in a laboratory activity.

\textbf{Experience -} Any lab activity that can be performed in an OL.

\textbf{OL -} Online laboratory.

\textbf{RIP -} Remote Interoperability Protocol.

\textbf{RL -} Remote laboratory.

\textbf{Simulation model -} A mathematical simulation that models a certain system with which laboratory activities can be carried out.

\textbf{SSE -} Server-sent events.

\textbf{VL -} Virtual laboratory.

\end{appendices}

\bibliographystyle{IEEEtran}
\renewcommand\bibname{References}
\bibliography{base/sources}